class Signal extends Set{constructor(){super(),this._onceCallbacksMap=new Map}add(e,{once:t=!1}={}){if(t){const t=()=>{e(...arguments),this.delete(e)};this._onceCallbacksMap.set(e,t),super.add(t)}else super.add(e)}delete(e){super.delete(this._onceCallbacksMap.get(e)||e),this._onceCallbacksMap.delete(e)}dispatch(e){for(let t of this)t(e)}}class Ticker extends Signal{constructor(){super(),this._updateBinded=this._update.bind(this),this.time=.001*window.performance.now(),this._previousTime=this.time,this.deltaTime=0,this.timeScale=1,this._update()}_update(){requestAnimationFrame(this._updateBinded),this.time=.001*window.performance.now(),this.deltaTime=this.time-this._previousTime,this.timeScale=this.deltaTime/.0166666667,this._previousTime=this.time,this.dispatch()}}var Ticker$1=new Ticker;class LoopElement extends HTMLElement{constructor({autoplay:e=!1,background:t=!1}={}){super(),this._autoplay=e||this.hasAttribute("autoplay"),this._background=t||this.hasAttribute("background"),this.paused=!0,this._pausedByBlur=!1,this._updateBinded=this.update.bind(this)}connectedCallback(){this._background||(window.top.addEventListener("blur",this._onBlur=()=>{this._pausedByBlur=!this.paused,this.pause()}),window.top.addEventListener("focus",this._onFocus=()=>{this._pausedByBlur&&this.play()})),(window.top.document.hasFocus()||this._background)&&this._autoplay?this.play():this._autoplay&&(this._pausedByBlur=!0,requestAnimationFrame(this._updateBinded))}disconnectedCallback(){this.pause(),window.top.removeEventListener("blur",this._onBlur),window.top.removeEventListener("focus",this._onFocus)}play(){this.paused=!1,this._pausedByBlur=!1,Ticker$1.add(this._updateBinded),this.dispatchEvent(new Event("playing"))}pause(){this.paused=!0,Ticker$1.delete(this._updateBinded),this.dispatchEvent(new Event("pause"))}update(){}}window.customElements.define("dlib-loop",LoopElement);const EPSILON=1e-6;let ARRAY_TYPE="undefined"==typeof Float32Array?Array:Float32Array;const degree=Math.PI/180;function create(){let e=new ARRAY_TYPE(2);return ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0),e}function copy(e,t){return e[0]=t[0],e[1]=t[1],e}function set(e,t,n){return e[0]=t,e[1]=n,e}function add(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e}function subtract(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e}function scale(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e}function distance(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)}function length(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}function squaredLength(e){var t=e[0],n=e[1];return t*t+n*n}function negate(e,t){return e[0]=-t[0],e[1]=-t[1],e}function normalize(e,t){var n=Math.sqrt,r=t[0],a=t[1],i=r*r+a*a;return 0<i&&(i=1/n(i),e[0]=t[0]*i,e[1]=t[1]*i),e}function dot(e,t){return e[0]*t[0]+e[1]*t[1]}function cross(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e}function lerp(e,n,r,a){var t=n[0],i=n[1];return e[0]=t+a*(r[0]-t),e[1]=i+a*(r[1]-i),e}function transformMat3(e,t,n){var r=t[0],a=t[1];return e[0]=n[0]*r+n[3]*a+n[6],e[1]=n[1]*r+n[4]*a+n[7],e}function transformMat4(e,t,n){let r=t[0],a=t[1];return e[0]=n[0]*r+n[4]*a+n[12],e[1]=n[1]*r+n[5]*a+n[13],e}function exactEquals(e,t){return e[0]===t[0]&&e[1]===t[1]}const forEach=function(){var e=Math.min;let t=create();return function(n,r,a,d,o,s){let u,c;for(r||(r=2),a||(a=0),c=d?e(d*r+a,n.length):n.length,u=a;u<c;u+=r)t[0]=n[u],t[1]=n[u+1],o(t,t,s),n[u]=t[0],n[u+1]=t[1];return n}}();class Vector2 extends Float32Array{static distance(e,t){return distance(e,t)}constructor(e=[0,0]){return super(e),this}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}set(e,t){return set(this,e,t),this}copy(e){return copy(this,e),this}add(e){return add(this,this,e),this}get size(){return length(this)}get squaredSize(){return squaredLength(this)}subtract(e){return subtract(this,this,e),this}negate(e=this){return negate(this,e),this}cross(e,t){return cross(this,e,t),this}scale(e){return scale(this,this,e),this}normalize(){normalize(this,this)}dot(e){return dot(this,e)}distance(e){return Vector2.distance(this,e)}equals(e){return exactEquals(this,e)}applyMatrix3(e){return transformMat3(this,this,e),this}applyMatrix4(e){return transformMat4(this,this,e),this}lerp(e,t){lerp(this,this,e,t)}clone(){return new Vector2(this)}}let pointers=new Map;class Pointer extends Vector2{static get TOUCH_TYPE(){return"touchtype"}static get MOUSE_TYPE(){return"mousetype"}static get(e=window){let t=pointers.get(e);return t||(t=new Pointer(e)),t}get downed(){return this._downed}constructor(e=window){super(),this._domElement=e,this.type=Pointer.TOUCH_TYPE,this.velocity=new Vector2,this.dragOffset=new Vector2,this.centered=new Vector2,this.centeredFlippedY=new Vector2,this.normalized=new Vector2,this.normalizedFlippedY=new Vector2,this.normalizedCentered=new Vector2,this.normalizedCenteredFlippedY=new Vector2,this._downed=!1,pointers.set(this._domElement,this),this.onDown=new Signal,this.onMove=new Signal,this.onUp=new Signal,this.onClick=new Signal,this.onTypeChange=new Signal,this._preventMouseTypeChange=!1,this._onPointerMoveBinded=this._onPointerMove.bind(this),this._onPointerDownBinded=this._onPointerDown.bind(this),this._onPointerUpBinded=this._onPointerUp.bind(this),this._updateBinded=this._update.bind(this),this._resizeBinded=this.resize.bind(this),this.resize(),this._position=new Vector2,this.enable()}resize(){this._domElementBoundingRect=this._domElement===window?{left:0,top:0,width:window.innerWidth,height:window.innerHeight}:this._domElement.getBoundingClientRect()}_onPointerDown(t){"touchstart"===t.type&&(this._preventMouseTypeChange=!0,this._changeType(Pointer.TOUCH_TYPE)),this._downed=!0,this.dragOffset.set(0,0),this.copy(this._position),this._onPointerEvent(t),this._updatePositions(),this.onDown.dispatch(t)}_onPointerMove(t){if("mousemove"===t.type){if(this._preventMouseTypeChange)return;this._changeType(Pointer.MOUSE_TYPE)}this._onPointerEvent(t),this.onMove.dispatch(t)}_onPointerUp(t){this._downed&&(this._downed=!1,this._onPointerEvent(t),this._updatePositions(),this.onUp.dispatch(t),4>this.dragOffset.length&&this.onClick.dispatch(t),clearTimeout(this._timeout),this._timeout=setTimeout(()=>{this._preventMouseTypeChange=!1},2e3))}_onPointerEvent(t){!!window.TouchEvent&&t instanceof window.TouchEvent&&("touchend"===t.type?t=t.changedTouches[0]:t=t.touches[0]),this._position.x=t.clientX-this._domElementBoundingRect.left,this._position.y=t.clientY-this._domElementBoundingRect.top}_changeType(e){this.type===e||(this.type=e,this.disable(),this.enable(),this.onTypeChange.dispatch(this.type))}_update(){(this.x||this.y)&&(this.velocity.x=this._position.x-this.x,this.velocity.y=this._position.y-this.y,this.downed&&this.dragOffset.add(this.velocity)),this._updatePositions()}_updatePositions(){this.x=this._position.x,this.y=this._position.y;(this.x||this.y)&&(this.centered.x=this.centeredFlippedY.x=this.x-.5*this._domElementBoundingRect.width,this.centered.y=this.centeredFlippedY.y=this.y-.5*this._domElementBoundingRect.height,this.centeredFlippedY.y*=-1,this.normalized.x=this.normalizedFlippedY.x=this.x/this._domElementBoundingRect.width,this.normalized.y=this.normalizedFlippedY.y=this.y/this._domElementBoundingRect.height,this.normalizedFlippedY.y=1-this.normalizedFlippedY.y,this.normalizedCentered.x=this.normalizedCenteredFlippedY.x=2*this.normalized.x-1,this.normalizedCentered.y=this.normalizedCenteredFlippedY.y=2*this.normalized.y-1,this.normalizedCenteredFlippedY.y*=-1)}enable(){this.disable(),this.resize(),this.type===Pointer.TOUCH_TYPE?(this._domElement.addEventListener("touchmove",this._onPointerMoveBinded),window.addEventListener("touchend",this._onPointerUpBinded)):(this._domElement.addEventListener("mousedown",this._onPointerDownBinded),window.addEventListener("mouseup",this._onPointerUpBinded)),this._domElement.addEventListener("touchstart",this._onPointerDownBinded),this._domElement.addEventListener("mousemove",this._onPointerMoveBinded),window.addEventListener("resize",this._resizeBinded),Ticker$1.add(this._updateBinded=this._updateBinded||this._update.bind(this))}disable(){Ticker$1.delete(this._updateBinded),this._domElement.removeEventListener("touchstart",this._onPointerDownBinded),this._domElement.removeEventListener("mousedown",this._onPointerDownBinded),this._domElement.removeEventListener("touchmove",this._onPointerMoveBinded),this._domElement.removeEventListener("mousemove",this._onPointerMoveBinded),window.removeEventListener("touchend",this._onPointerUpBinded),window.removeEventListener("mouseup",this._onPointerUpBinded),window.removeEventListener("resize",this._resizeBinded)}}function copy$1(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function set$1(e,t,n,r,a,i,d,o,s,u,c,m,p,h,l,_,f){return e[0]=t,e[1]=n,e[2]=r,e[3]=a,e[4]=i,e[5]=d,e[6]=o,e[7]=s,e[8]=u,e[9]=c,e[10]=m,e[11]=p,e[12]=h,e[13]=l,e[14]=_,e[15]=f,e}function identity(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function invert(e,t){let n=t[0],r=t[1],a=t[2],i=t[3],d=t[4],o=t[5],s=t[6],u=t[7],c=t[8],m=t[9],p=t[10],h=t[11],l=t[12],_=t[13],f=t[14],x=t[15],v=n*o-r*d,y=n*s-a*d,g=n*u-i*d,S=r*s-a*o,T=r*u-i*o,C=a*u-i*s,E=c*_-m*l,b=c*f-p*l,k=c*x-h*l,B=m*f-p*_,z=m*x-h*_,M=p*x-h*f,P=v*M-y*z+g*B+S*k-T*b+C*E;return P?(P=1/P,e[0]=(o*M-s*z+u*B)*P,e[1]=(a*z-r*M-i*B)*P,e[2]=(_*C-f*T+x*S)*P,e[3]=(p*T-m*C-h*S)*P,e[4]=(s*k-d*M-u*b)*P,e[5]=(n*M-a*k+i*b)*P,e[6]=(f*g-l*C-x*y)*P,e[7]=(c*C-p*g+h*y)*P,e[8]=(d*z-o*k+u*E)*P,e[9]=(r*k-n*z-i*E)*P,e[10]=(l*T-_*g+x*v)*P,e[11]=(m*g-c*T-h*v)*P,e[12]=(o*b-d*B-s*E)*P,e[13]=(n*B-r*b+a*E)*P,e[14]=(_*y-l*S-f*v)*P,e[15]=(c*S-m*y+p*v)*P,e):null}function multiply$1(e,t,n){let r=t[0],a=t[1],i=t[2],d=t[3],o=t[4],s=t[5],u=t[6],c=t[7],m=t[8],p=t[9],h=t[10],l=t[11],_=t[12],f=t[13],x=t[14],v=t[15],y=n[0],g=n[1],S=n[2],T=n[3];return e[0]=y*r+g*o+S*m+T*_,e[1]=y*a+g*s+S*p+T*f,e[2]=y*i+g*u+S*h+T*x,e[3]=y*d+g*c+S*l+T*v,y=n[4],g=n[5],S=n[6],T=n[7],e[4]=y*r+g*o+S*m+T*_,e[5]=y*a+g*s+S*p+T*f,e[6]=y*i+g*u+S*h+T*x,e[7]=y*d+g*c+S*l+T*v,y=n[8],g=n[9],S=n[10],T=n[11],e[8]=y*r+g*o+S*m+T*_,e[9]=y*a+g*s+S*p+T*f,e[10]=y*i+g*u+S*h+T*x,e[11]=y*d+g*c+S*l+T*v,y=n[12],g=n[13],S=n[14],T=n[15],e[12]=y*r+g*o+S*m+T*_,e[13]=y*a+g*s+S*p+T*f,e[14]=y*i+g*u+S*h+T*x,e[15]=y*d+g*c+S*l+T*v,e}function translate(e,t,n){let r,a,i,d,o,s,u,c,m,p,h,l,_=n[0],f=n[1],x=n[2];return t===e?(e[12]=t[0]*_+t[4]*f+t[8]*x+t[12],e[13]=t[1]*_+t[5]*f+t[9]*x+t[13],e[14]=t[2]*_+t[6]*f+t[10]*x+t[14],e[15]=t[3]*_+t[7]*f+t[11]*x+t[15]):(r=t[0],a=t[1],i=t[2],d=t[3],o=t[4],s=t[5],u=t[6],c=t[7],m=t[8],p=t[9],h=t[10],l=t[11],e[0]=r,e[1]=a,e[2]=i,e[3]=d,e[4]=o,e[5]=s,e[6]=u,e[7]=c,e[8]=m,e[9]=p,e[10]=h,e[11]=l,e[12]=r*_+o*f+m*x+t[12],e[13]=a*_+s*f+p*x+t[13],e[14]=i*_+u*f+h*x+t[14],e[15]=d*_+c*f+l*x+t[15]),e}function scale$1(e,t,n){let r=n[0],a=n[1],i=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*a,e[5]=t[5]*a,e[6]=t[6]*a,e[7]=t[7]*a,e[8]=t[8]*i,e[9]=t[9]*i,e[10]=t[10]*i,e[11]=t[11]*i,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function rotateX(e,t,n){var r=Math.cos,a=Math.sin;let i=a(n),d=r(n),o=t[4],s=t[5],u=t[6],c=t[7],m=t[8],p=t[9],h=t[10],l=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*d+m*i,e[5]=s*d+p*i,e[6]=u*d+h*i,e[7]=c*d+l*i,e[8]=m*d-o*i,e[9]=p*d-s*i,e[10]=h*d-u*i,e[11]=l*d-c*i,e}function rotateY(e,t,n){var r=Math.cos,a=Math.sin;let i=a(n),d=r(n),o=t[0],s=t[1],u=t[2],c=t[3],m=t[8],p=t[9],h=t[10],l=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*d-m*i,e[1]=s*d-p*i,e[2]=u*d-h*i,e[3]=c*d-l*i,e[8]=o*i+m*d,e[9]=s*i+p*d,e[10]=u*i+h*d,e[11]=c*i+l*d,e}function rotateZ(e,t,n){var r=Math.cos,a=Math.sin;let i=a(n),d=r(n),o=t[0],s=t[1],u=t[2],c=t[3],m=t[4],p=t[5],h=t[6],l=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*d+m*i,e[1]=s*d+p*i,e[2]=u*d+h*i,e[3]=c*d+l*i,e[4]=m*d-o*i,e[5]=p*d-s*i,e[6]=h*d-u*i,e[7]=l*d-c*i,e}function fromQuat(e,t){let n=t[0],r=t[1],a=t[2],i=t[3],d=n+n,o=r+r,s=a+a,u=n*d,c=r*d,m=r*o,p=a*d,h=a*o,l=a*s,_=i*d,f=i*o,x=i*s;return e[0]=1-m-l,e[1]=c+x,e[2]=p-f,e[3]=0,e[4]=c-x,e[5]=1-u-l,e[6]=h+_,e[7]=0,e[8]=p+f,e[9]=h-_,e[10]=1-u-m,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function perspective(e,t,n,r,a){var i=Math.tan;let d,o=1/i(t/2);return e[0]=o/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=a&&a!==1/0?(d=1/(r-a),e[10]=(a+r)*d,e[14]=2*a*r*d):(e[10]=-1,e[14]=-2*r),e}class Matrix4 extends Float32Array{constructor(e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){return super(e),this}set x(e){this[12]=e}get x(){return this[12]}set y(e){this[13]=e}get y(){return this[13]}set z(e){this[14]=e}get z(){return this[14]}set w(e){this[15]=e}get w(){return this[15]}set(e,t,n,r,a,i,d,o,s,u,c,m,p,h,l,_){return e.length?this.copy(e):(set$1(this,e,t,n,r,a,i,d,o,s,u,c,m,p,h,l,_),this)}translate(e,t=this){return translate(this,t,e),this}rotateX(e,t=this){return rotateX(this,t,e),this}rotateY(e,t=this){return rotateY(this,t,e),this}rotateZ(e,t=this){return rotateZ(this,t,e),this}scale(e,t=this){return scale$1(this,t,"number"==typeof e?[e,e,e]:e),this}multiply(e,t){return t?multiply$1(this,e,t):multiply$1(this,this,e),this}identity(){return identity(this),this}copy(e){return copy$1(this,e),this}fromPerspective({fov:e,aspectRatio:t,near:n,far:r}={}){return perspective(this,e,t,n,r),this}fromQuaternion(e){return fromQuat(this,e),this}setPosition(e){return this.x=e[0],this.y=e[1],this.z=e[2],this}invert(e=this){return invert(this,e),this}}function create$2(){let e=new ARRAY_TYPE(3);return ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function length$1(e){let t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)}function fromValues$2(e,t,n){let r=new ARRAY_TYPE(3);return r[0]=e,r[1]=t,r[2]=n,r}function copy$2(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function set$2(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function add$2(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function subtract$2(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function scale$2(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function distance$1(e,t){let n=t[0]-e[0],r=t[1]-e[1],a=t[2]-e[2];return Math.sqrt(n*n+r*r+a*a)}function squaredLength$1(e){let t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r}function negate$1(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}function normalize$1(e,t){var n=Math.sqrt;let r=t[0],a=t[1],i=t[2],d=r*r+a*a+i*i;return 0<d&&(d=1/n(d),e[0]=t[0]*d,e[1]=t[1]*d,e[2]=t[2]*d),e}function dot$1(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function cross$1(e,t,n){let r=t[0],a=t[1],i=t[2],d=n[0],o=n[1],s=n[2];return e[0]=a*s-i*o,e[1]=i*d-r*s,e[2]=r*o-a*d,e}function transformMat4$1(e,t,n){let r=t[0],a=t[1],i=t[2],d=n[3]*r+n[7]*a+n[11]*i+n[15];return d=d||1,e[0]=(n[0]*r+n[4]*a+n[8]*i+n[12])/d,e[1]=(n[1]*r+n[5]*a+n[9]*i+n[13])/d,e[2]=(n[2]*r+n[6]*a+n[10]*i+n[14])/d,e}function angle$1(e,t){var n=Math.acos,r=Math.PI;let a=fromValues$2(e[0],e[1],e[2]),i=fromValues$2(t[0],t[1],t[2]);normalize$1(a,a),normalize$1(i,i);let d=dot$1(a,i);return 1<d?0:-1>d?r:n(d)}function exactEquals$2(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}const len$1=length$1,forEach$1=function(){var e=Math.min;let t=create$2();return function(n,r,a,d,o,s){let u,c;for(r||(r=3),a||(a=0),c=d?e(d*r+a,n.length):n.length,u=a;u<c;u+=r)t[0]=n[u],t[1]=n[u+1],t[2]=n[u+2],o(t,t,s),n[u]=t[0],n[u+1]=t[1],n[u+2]=t[2];return n}}();class Vector3 extends Float32Array{constructor(e=[0,0,0]){return super(e),this}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}set(e,t,n){return set$2(this,e,t,n),this}copy(e){return copy$2(this,e),this}add(e){return add$2(this,this,e),this}get size(){return length$1(this)}get squaredSize(){return squaredLength$1(this)}distance(e){return distance$1(this,e)}subtract(e){return subtract$2(this,this,e),this}negate(e=this){return negate$1(this,e),this}cross(e,t){return cross$1(this,e,t),this}scale(e){return scale$2(this,this,e),this}normalize(){return normalize$1(this,this),this}dot(e){return dot$1(this,e)}equals(e){return exactEquals$2(this,e)}applyMatrix4(e){return transformMat4$1(this,this,e),this}angle(e){return angle$1(this,e)}clone(){return new Vector3(this)}}function create$3(){let e=new ARRAY_TYPE(9);return ARRAY_TYPE!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function create$4(){let e=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function copy$4(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function set$4(e,t,n,r,a){return e[0]=t,e[1]=n,e[2]=r,e[3]=a,e}function normalize$2(e,t){var n=Math.sqrt;let r=t[0],a=t[1],i=t[2],d=t[3],o=r*r+a*a+i*i+d*d;return 0<o&&(o=1/n(o),e[0]=r*o,e[1]=a*o,e[2]=i*o,e[3]=d*o),e}const forEach$2=function(){var e=Math.min;let t=create$4();return function(n,r,a,d,o,s){let u,c;for(r||(r=4),a||(a=0),c=d?e(d*r+a,n.length):n.length,u=a;u<c;u+=r)t[0]=n[u],t[1]=n[u+1],t[2]=n[u+2],t[3]=n[u+3],o(t,t,s),n[u]=t[0],n[u+1]=t[1],n[u+2]=t[2],n[u+3]=t[3];return n}}();function create$5(){let e=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function identity$2(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}function setAxisAngle(e,t,n){var r=Math.cos,a=Math.sin;n*=.5;let i=a(n);return e[0]=i*t[0],e[1]=i*t[1],e[2]=i*t[2],e[3]=r(n),e}function multiply$5(e,t,n){let r=t[0],a=t[1],i=t[2],d=t[3],o=n[0],s=n[1],u=n[2],c=n[3];return e[0]=r*c+d*o+a*u-i*s,e[1]=a*c+d*s+i*o-r*u,e[2]=i*c+d*u+r*s-a*o,e[3]=d*c-r*o-a*s-i*u,e}function rotateX$2(e,t,n){var r=Math.cos,a=Math.sin;n*=.5;let i=t[0],d=t[1],o=t[2],s=t[3],u=a(n),c=r(n);return e[0]=i*c+s*u,e[1]=d*c+o*u,e[2]=o*c-d*u,e[3]=s*c-i*u,e}function rotateY$2(e,t,n){var r=Math.cos,a=Math.sin;n*=.5;let i=t[0],d=t[1],o=t[2],s=t[3],u=a(n),c=r(n);return e[0]=i*c-o*u,e[1]=d*c+s*u,e[2]=o*c+i*u,e[3]=s*c-d*u,e}function rotateZ$2(e,t,n){var r=Math.cos,a=Math.sin;n*=.5;let i=t[0],d=t[1],o=t[2],s=t[3],u=a(n),c=r(n);return e[0]=i*c+d*u,e[1]=d*c-i*u,e[2]=o*c+s*u,e[3]=s*c-o*u,e}function slerp(e,n,r,a){var t=Math.acos,i=Math.sin;let d,o,s,u,c,m=n[0],p=n[1],h=n[2],l=n[3],_=r[0],f=r[1],x=r[2],v=r[3];return o=m*_+p*f+h*x+l*v,0>o&&(o=-o,_=-_,f=-f,x=-x,v=-v),1-o>EPSILON?(d=t(o),s=i(d),u=i((1-a)*d)/s,c=i(a*d)/s):(u=1-a,c=a),e[0]=u*m+c*_,e[1]=u*p+c*f,e[2]=u*h+c*x,e[3]=u*l+c*v,e}function invert$2(e,t){let n=t[0],r=t[1],a=t[2],i=t[3],d=n*n+r*r+a*a+i*i,o=d?1/d:0;return e[0]=-n*o,e[1]=-r*o,e[2]=-a*o,e[3]=i*o,e}function fromMat3(e,t){var n=Math.sqrt;let r,a=t[0]+t[4]+t[8];if(0<a)r=n(a+1),e[3]=.5*r,r=.5/r,e[0]=(t[5]-t[7])*r,e[1]=(t[6]-t[2])*r,e[2]=(t[1]-t[3])*r;else{let a=0;t[4]>t[0]&&(a=1),t[8]>t[3*a+a]&&(a=2);let i=(a+1)%3,d=(a+2)%3;r=n(t[3*a+a]-t[3*i+i]-t[3*d+d]+1),e[a]=.5*r,r=.5/r,e[3]=(t[3*i+d]-t[3*d+i])*r,e[i]=(t[3*i+a]+t[3*a+i])*r,e[d]=(t[3*d+a]+t[3*a+d])*r}return e}const copy$5=copy$4,set$5=set$4,normalize$3=normalize$2,rotationTo=function(){let e=create$2(),t=fromValues$2(1,0,0),n=fromValues$2(0,1,0);return function(r,i,a){let d=dot$1(i,a);return-.999999>d?(cross$1(e,t,i),1e-6>len$1(e)&&cross$1(e,n,i),normalize$1(e,e),setAxisAngle(r,e,Math.PI),r):.999999<d?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(cross$1(e,i,a),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+d,normalize$3(r,r))}}(),sqlerp=function(){let e=create$5(),n=create$5();return function(r,i,a,o,s,d){return slerp(e,i,s,d),slerp(n,a,o,d),slerp(r,e,n,2*d*(1-d)),r}}(),setAxes=function(){let e=create$3();return function(t,n,r,a){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=a[0],e[4]=a[1],e[7]=a[2],e[2]=-n[0],e[5]=-n[1],e[8]=-n[2],normalize$3(t,fromMat3(t,e))}}();class Quaternion extends Float32Array{constructor(e=0,t=0,n=0,r=1){return super(4),this.set(e,t,n,r),this}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}get w(){return this[3]}set w(e){this[3]=e}identity(){return identity$2(this),this}set(e,t,n,r){return set$5(this,e,t,n,r),this}rotateX(e){return rotateX$2(this,this,e),this}rotateY(e){return rotateY$2(this,this,e),this}rotateZ(e){return rotateZ$2(this,this,e),this}invert(e=this){return invert$2(this,e),this}copy(e){return copy$5(this,e),this}normalize(e=this){return normalize$3(this,this),this}multiply(e,t){return t?multiply$5(this,e,t):multiply$5(this,this,e),this}fromMatrix3(e){return fromMat3(this,e),this}}class TrackballController{constructor({matrix:e=new Matrix4,domElement:t=document.body,distance:n=0,invertRotation:r=!0,rotationEaseRatio:a=.04,zoomSpeed:i=.1,zoomEaseRatio:d=.1,minDistance:o=0,maxDistance:s=1/0,enabled:u=!0}={}){this.matrix=e,this._distance=n,this.invertRotation=r,this.rotationEaseRatio=a,this.maxDistance=s,this.minDistance=o,this.zoomSpeed=i,this.zoomEaseRatio=d,this._pointer=Pointer.get(t),this._nextDistance=this._distance,this._cachedQuaternion=new Quaternion,this._cachedMatrix=new Matrix4,this._cachedVector3=new Vector3,this._velocity=new Vector2,this._velocityOrigin=new Vector2,this._position=new Vector3([this.matrix.x,this.matrix.y,this.matrix.z]),this._positionPrevious=this._position.clone(),this._positionOffset=new Vector3,t.addEventListener("wheel",this.onWheel.bind(this)),this.enabled=!0,this.update(),this.enabled=u}set distance(e){this._distance=this._nextDistance=e}get distance(){return this._distance}onWheel(t){var e=Math.max,n=Math.abs,r=Math.min;if(this.enabled){const a=1+n(.01*(t.deltaY*this.zoomSpeed));this._nextDistance=this._nextDistance||1,this._nextDistance=0<t.deltaY?this._nextDistance*a:this._nextDistance/a,this._nextDistance=e(r(this._nextDistance,this.maxDistance),this.minDistance)}}update(){this.enabled&&(this._cachedMatrix.identity(),this._cachedQuaternion.identity(),this._distance+=(this._nextDistance-this._distance)*this.zoomEaseRatio,this._position.set(this.matrix.x,this.matrix.y,this.matrix.z).subtract(this._positionOffset),this.matrix.x=0,this.matrix.y=0,this.matrix.z=0,this._pointer.downed&&this._velocity.copy(this._pointer.velocity).scale(.003),this._velocity.lerp(this._velocityOrigin,this.rotationEaseRatio),this._cachedQuaternion.rotateY(this.invertRotation?-this._velocity.x:this._velocity.x),this._cachedQuaternion.rotateX(this.invertRotation?-this._velocity.y:this._velocity.y),this._cachedMatrix.fromQuaternion(this._cachedQuaternion),this.matrix.multiply(this._cachedMatrix),this._positionOffset.set(0,0,1),this._positionOffset.applyMatrix4(this.matrix),this._positionOffset.scale(this._distance),this._cachedVector3.copy(this._position).add(this._positionOffset),this.matrix.x=this._cachedVector3.x,this.matrix.y=this._cachedVector3.y,this.matrix.z=this._cachedVector3.z)}}class THREETrackballController extends TrackballController{constructor(e=new THREE.Object3D,t){e.updateMatrix(),super(Object.assign({matrix:new Matrix4(e.matrix.elements)},t)),this._matrix4=new THREE.Matrix4,this.object3D=e;const n=this.enabled;this.enabled=!0,this.update(),this.enabled=n}update(){this.object3D&&(this.matrix.x=this.object3D.position.x,this.matrix.y=this.object3D.position.y,this.matrix.z=this.object3D.position.z,super.update(),this._matrix4.fromArray(this.matrix),this.object3D.matrix.identity(),this.object3D.applyMatrix(this._matrix4))}}class Scene extends THREE.Scene{constructor({canvas:e}={}){super(),this.camera=new THREE.PerspectiveCamera(65,window.innerWidth/window.innerHeight,.1,1e4),this.controls=new THREETrackballController(this.camera,{distance:5,domElement:e});let t=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshNormalMaterial());this.add(t)}resize(e,t){this.camera.aspect=e/t,this.camera.updateProjectionMatrix()}update(){this.controls.update()}}class THREERenderer extends THREE.WebGLRenderer{constructor(e){super(Object.assign({antialias:!0},e)),this.filters=[],this._renderTargets=new Map;let t=new THREE.WebGLRenderTarget(this.domElement.width,this.domElement.height,{format:THREE.RGBAFormat,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,stencilBuffer:!1});t.texture.generateMipmaps=!1;let n=t.clone();n.texture.generateMipmaps=!1,this.context.getExtension("WEBGL_depth_texture")&&(t.depthTexture=new THREE.DepthTexture,t.depthTexture.type=THREE.UnsignedShortType,n.depthTexture=new THREE.DepthTexture,n.depthTexture.type=THREE.UnsignedShortType),this._renderTargets.set(this,{in:t,out:n}),this.scene=new THREE.Scene,this.scene.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this._quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2)),this._quad.frustumCulled=!1,this.scene.add(this._quad),this._render=this.render,delete this.render}applyFilter(e,t,n){this._quad.material=e,e.renderTargetTexture&&(e.renderTargetTexture=t.texture),e.renderTargetDepthTexture&&t.depthTexture&&(e.renderTargetDepthTexture=t.depthTexture),this._render(this.scene,this.scene.camera,n)}resize(e,t){this.setSize(e,t,!1);let n=this._renderTargets.get(this);n.in.setSize(e,t),n.out.setSize(e,t)}render({scene:e,camera:t,filters:a=this.filters,renderTarget:n,viewport:r,scissor:i=r}={}){if(1<arguments.length)return void this._render(...arguments);let d=this._renderTargets.get(n||this);d||(d={in:n.clone(),out:n.clone()},d.in.texture.generateMipmaps=!1,d.out.texture.generateMipmaps=!1,this._renderTargets.set(n,d)),r||i?(r&&(n?n.viewport.set(r[0],r[1],r[2],r[3]):this.setViewport(r[0],r[1],r[2],r[3])),n?(n.scissor.set(i[0],i[1],i[2],i[3]),n.scissorTest=!0):(this.setScissor(i[0],i[1],i[2],i[3]),this.setScissorTest(!0))):n?(n.viewport.set(0,0,n.width,n.height),n.scissor.set(0,0,n.width,n.height),n.scissorTest=!1):(this.setViewport(0,0,this.domElement.width,this.domElement.height),this.setScissor(0,0,this.domElement.width,this.domElement.height),this.setScissorTest(!1)),e&&(t=t||e.camera,this._render(e,t,a.length?d.in:n));for(let[o,s]of a.entries())this.applyFilter(s,d.in,o<a.length-1?d.out:n),[d.in,d.out]=[d.out,d.in]}}class Shader{static add(e="void main() {}",t){for(let[n,r]of t)e="start"===n?e.replace(/^(#version .*?\n(\s*precision highp float;\s)?)?([\s\S]*)/,`$1\n${r}\n$3`):"end"===n?e.replace(/(}\s*$)/,`\n${r}\n$1`):"main"===n?e.replace(/(\bvoid\b +\bmain\b[\s\S]*?{\s*)/,`$1\n${r}\n`):e.replace(n,r);return e}constructor({vertexShader:e=`#version 300 es
      void main() {
        gl_Position = vec4(0., 0., 0., 1.);
      }
    `,fragmentShader:t=`#version 300 es
      precision highp float;

      out vec4 fragColor;

      void main() {
        fragColor = vec4(1.);
      }
    `,dataTypeConctructors:n={Vector2:class extends Float32Array{constructor(){super(2)}},Vector3:class extends Float32Array{constructor(){super(3)}},Vector4:class extends Float32Array{constructor(){super(4)}},Matrix3:class extends Float32Array{constructor(){super([1,0,0,0,1,0,0,0,1])}},Matrix4:class extends Float32Array{constructor(){super([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}},Texture:class{},TextureCube:class{}},uniforms:r=[],vertexShaderChunks:a=[],fragmentShaderChunks:i=[],shaders:d=[]}={}){this.uniforms=new Map,this.uniformTypes=new Map,this._dataTypeConctructors=n,this.vertexShader=e,this.fragmentShader=t,this._vertexShaderChunks=[],this._fragmentShaderChunks=[],this.add({vertexShaderChunks:a,fragmentShaderChunks:i,uniforms:r});for(let o of d)this.add(o)}add({vertexShaderChunks:e=[],fragmentShaderChunks:t=[],uniforms:n=[]}={}){this.vertexShader=Shader.add(this.vertexShader,e),this._vertexShaderChunks.push(...e),this.fragmentShader=Shader.add(this.fragmentShader,t),this._fragmentShaderChunks.push(...t);for(let[r,a]of n)this.uniforms.set(r,a)}set vertexShader(e){this._vertexShader=e,this._parseUniforms(this._vertexShader)}get vertexShader(){return this._vertexShader}set fragmentShader(e){this._fragmentShader=e,this._parseUniforms(this._fragmentShader)}get fragmentShader(){return this._fragmentShader}get vertexShaderChunks(){return this._vertexShaderChunks}get fragmentShaderChunks(){return this._fragmentShaderChunks}_addUniform(e,t,n){if(this.uniforms.has(e))return;let r,a;if(this.uniformTypes.set(e,t),/float|double/.test(t))r=isNaN(n)?0:Array(n).fill(0);else if(/int|uint/.test(t))r=isNaN(n)?0:Array(n).fill(0);else if(/sampler2D/.test(t))r=isNaN(n)?new this._dataTypeConctructors.Texture:Array(n).fill().map(()=>new this._dataTypeConctructors.Texture);else if(/samplerCube/.test(t))r=isNaN(n)?new this._dataTypeConctructors.TextureCube:Array(n).fill().map(()=>new this._dataTypeConctructors.TextureCube);else if(a=/(.?)vec(\d)/.exec(t)){let e=a[2];r=isNaN(n)?new this._dataTypeConctructors[`Vector${e}`]:Array(n).fill().map(()=>new this._dataTypeConctructors[`Vector${e}`])}else if(a=/mat(\d)/.exec(t)){let e=a[1];r=isNaN(n)?new this._dataTypeConctructors[`Matrix${e}`]:Array(n).fill().map(()=>new this._dataTypeConctructors[`Matrix${e}`])}else r=void 0;this.uniforms.set(e,r)}_parseUniforms(e){const t=new Map,n=/struct\s*(.*)\s*{\s*([\s\S]*?)}/g,r=/^\s*(.[^ ]+) (.[^ ;\[\]]+)\[? *(\d+)? *\]?/gm;for(let a;a=n.exec(e);){const e=a[1],n=a[2],i={};for(let e;e=r.exec(n);){const[,t,n,r]=e,a=parseInt(r);i[n]={type:t,arrayLength:a}}t.set(e,i)}const a=/^\s*uniform (.[^ ]+) (.[^ ;\[\]]+)\[? *(\d+)? *\]?/gm;for(let n;n=a.exec(e);){const[,e,r,a]=n,i=parseInt(a),d=t.get(e);if(d)for(const e in d)this._addUniform(`${r}.${e}`,d[e].type,d[e].arrayLength);else this._addUniform(r,e,i)}}}class THREEShader extends Shader{constructor({vertexShader:n=`
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    }
  `,fragmentShader:r=`
    void main() {
      gl_FragColor = vec4(1.);
    }
  `,uniforms:e,shaders:t}={}){super({vertexShader:n,fragmentShader:r,uniforms:e,shaders:t,dataTypeConctructors:{Vector2:THREE.Vector2,Vector3:THREE.Vector3,Vector4:THREE.Vector4,Matrix3:THREE.Matrix3,Matrix4:THREE.Matrix4,Texture:THREE.Texture,TextureCube:THREE.CubeTexture}})}add({vertexShaderChunks:e=[],fragmentShaderChunks:t=[],uniforms:n=[]}={}){if(!(n instanceof Array||n instanceof Map)){const e=n;for(let t in n=new Map,e)n.set(t,void 0===e[t].value?e[t]:e[t].value)}if(!(this.uniforms instanceof Array||this.uniforms instanceof Map)){const e=this.uniforms;for(let t in this.uniforms=new Map,e)this.uniforms.set(t,void 0===e[t].value?e[t]:e[t].value)}super.add({vertexShaderChunks:e,fragmentShaderChunks:t,uniforms:n});const r={};for(let[a,i]of this.uniforms)r[a]={value:i};this.uniforms=r}}class THREEShaderMaterial extends THREE.ShaderMaterial{constructor(e={}){let t=e.type||"",n=e.vertexShaderChunks,r=e.fragmentShaderChunks,a=e.uniforms,i=e.shaders||[];e=Object.assign({},e),delete e.type,delete e.vertexShaderChunks,delete e._vertexShaderChunks,delete e._vertexShader,delete e.fragmentShaderChunks,delete e._fragmentShaderChunks,delete e._fragmentShader,delete e.uniforms,delete e.attributes,delete e.shaders;let d=new THREEShader({vertexShader:e.vertexShader||(t?THREE.ShaderLib[t].vertexShader:void 0),fragmentShader:e.fragmentShader||(t?THREE.ShaderLib[t].fragmentShader:void 0),uniforms:t?THREE.UniformsUtils.clone(THREE.ShaderLib[t].uniforms):void 0});super(Object.assign({fragmentShader:d.fragmentShader,vertexShader:d.vertexShader,uniforms:d.uniforms},e)),this.defines={[t.toUpperCase()]:""},this._shader=d,this.add({vertexShaderChunks:n,fragmentShaderChunks:r,uniforms:a});for(let t of i)this.add(t);this.lights=/lambert|phong|standard/.test(t),this.envMap&&(this.envMap=this.envMap)}add({vertexShaderChunks:e,fragmentShaderChunks:t,uniforms:n}){var r=Math.max;for(let a in this._shader.add({vertexShaderChunks:e,fragmentShaderChunks:t,uniforms:n}),this.fragmentShader=this._shader.fragmentShader,this.vertexShader=this._shader.vertexShader,this._shader.uniforms){let e=a;this.uniforms[e]=this._shader.uniforms[e];let t;t="envMap"==e?function(t){var n=Math.log2;t&&t.generateMipmaps&&t.image&&(this.maxMipLevel=n(r(t.image.width,t.image.height))),this.uniforms[e].value=t}:function(t){this.uniforms[e].value=t},Object.defineProperty(this,e,{configurable:!0,get:function(){return this.uniforms[e].value},set:t})}this.needsUpdate=!0}}class AntialiasGLSL{static vertex(){return`
      varying vec2 v_rgbNW;
      varying vec2 v_rgbNE;
      varying vec2 v_rgbSW;
      varying vec2 v_rgbSE;
      varying vec2 v_rgbM;

      void computeFXAATextureCoordinates(vec2 uv, vec2 resolution) {
        vec2 inverseVP = 1.0 / resolution.xy;
        vec2 fragCoord = uv * resolution;
        v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
        v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
        v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
        v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
        v_rgbM = vec2(fragCoord * inverseVP);
      }
    `}static fragment(){return`
      varying vec2 v_rgbNW;
      varying vec2 v_rgbNE;
      varying vec2 v_rgbSW;
      varying vec2 v_rgbSE;
      varying vec2 v_rgbM;

      #ifndef FXAA_REDUCE_MIN
      #define FXAA_REDUCE_MIN   (1.0/ 128.0)
      #endif
      #ifndef FXAA_REDUCE_MUL
      #define FXAA_REDUCE_MUL   (1.0 / 8.0)
      #endif
      #ifndef FXAA_SPAN_MAX
      #define FXAA_SPAN_MAX     8.0
      #endif

      vec4 fxaa(sampler2D tex, vec2 uv, vec2 resolution) {
        vec4 color;
        vec2 fragCoord = uv * resolution;
        mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
        vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
        vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
        vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
        vec4 texColor = texture2D(tex, v_rgbM);
        vec3 rgbM  = texColor.xyz;
        vec3 luma = vec3(0.299, 0.587, 0.114);
        float lumaNW = dot(rgbNW, luma);
        float lumaNE = dot(rgbNE, luma);
        float lumaSW = dot(rgbSW, luma);
        float lumaSE = dot(rgbSE, luma);
        float lumaM  = dot(rgbM,  luma);
        float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
        float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

        mediump vec2 dir;
        dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
        dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

        float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
        (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

        float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
        dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
        max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
        dir * rcpDirMin)) * inverseVP;

        vec3 rgbA = 0.5 * (
        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
        vec3 rgbB = rgbA * 0.5 + 0.25 * (
          texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
          texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

        float lumaB = dot(rgbB, luma);
        if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
        else
        color = vec4(rgbB, texColor.a);
        return color;
      }
    `}}class Renderer extends THREERenderer{constructor(e){super(e),!1===e.antialias||this.context.getContextAttributes().antialias||this.filters.push(this.fxaaFilter=new THREEShaderMaterial({vertexShader:`
          uniform vec2 resolution;
          varying vec2 vUv;
          ${AntialiasGLSL.vertex()}
          void main() {
            computeFXAATextureCoordinates(uv, resolution);
            vUv = uv;
            gl_Position = vec4(position, 1.);
          }
        `,fragmentShader:`
          uniform vec2 resolution;
          uniform sampler2D renderTargetTexture;
          varying vec2 vUv;
          ${AntialiasGLSL.fragment()}
          void main() {
            gl_FragColor = fxaa(renderTargetTexture, vUv, resolution);
          }
        `}))}resize(e,t){e*=window.devicePixelRatio,t*=window.devicePixelRatio,super.resize(e,t),this.fxaaFilter&&this.fxaaFilter.resolution.set(e,t)}}window.customElements.define("dnit-main",class extends LoopElement{connectedCallback(){super.connectedCallback(),this.innerHTML=`
      <style>
        @import "src/main/index.css";
      </style>
      <canvas></canvas>
    `,this.canvas=this.querySelector("canvas"),this.renderer=new Renderer({canvas:this.canvas}),this.scene=new Scene({canvas:this.canvas}),this.querySelector("style").addEventListener("load",()=>{this.dispatchEvent(new Event("load")),this.resize(),this.play()}),window.addEventListener("resize",this._resizeBinded=this.resize.bind(this))}disconnectedCallback(){super.disconnectedCallback(),window.removeEventListener("resize",this._resizeBinded)}resize(){let e=this.canvas.offsetWidth,t=this.canvas.offsetHeight;this.scene.resize(e,t),this.renderer.resize(e,t),this.renderer.render({scene:this.scene})}update(){this.scene.update(),this.renderer.render({scene:this.scene})}});